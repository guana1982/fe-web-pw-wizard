(self["webpackChunkfe_web_pw_wizard"] = self["webpackChunkfe_web_pw_wizard"] || []).push([["node_modules_ngrx_router-store_fesm2022_ngrx-router-store_mjs-_777d0"],{

/***/ 58989:
/*!*************************************************************************!*\
  !*** ./node_modules/rxjs/dist/esm/internal/operators/withLatestFrom.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   withLatestFrom: () => (/* binding */ withLatestFrom)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ 34114);
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OperatorSubscriber */ 35678);
/* harmony import */ var _observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../observable/innerFrom */ 60384);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/identity */ 10204);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/noop */ 72707);
/* harmony import */ var _util_args__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/args */ 76190);






function withLatestFrom(...inputs) {
  const project = (0,_util_args__WEBPACK_IMPORTED_MODULE_0__.popResultSelector)(inputs);
  return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)((source, subscriber) => {
    const len = inputs.length;
    const otherValues = new Array(len);
    let hasValue = inputs.map(() => false);
    let ready = false;
    for (let i = 0; i < len; i++) {
      (0,_observable_innerFrom__WEBPACK_IMPORTED_MODULE_2__.innerFrom)(inputs[i]).subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_3__.createOperatorSubscriber)(subscriber, value => {
        otherValues[i] = value;
        if (!ready && !hasValue[i]) {
          hasValue[i] = true;
          (ready = hasValue.every(_util_identity__WEBPACK_IMPORTED_MODULE_4__.identity)) && (hasValue = null);
        }
      }, _util_noop__WEBPACK_IMPORTED_MODULE_5__.noop));
    }
    source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_3__.createOperatorSubscriber)(subscriber, value => {
      if (ready) {
        const values = [value, ...otherValues];
        subscriber.next(project ? project(...values) : values);
      }
    }));
  });
}

/***/ }),

/***/ 1794:
/*!************************************************************************!*\
  !*** ./node_modules/@ngrx/router-store/fesm2022/ngrx-router-store.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_ROUTER_FEATURENAME: () => (/* binding */ DEFAULT_ROUTER_FEATURENAME),
/* harmony export */   FullRouterStateSerializer: () => (/* binding */ FullRouterStateSerializer),
/* harmony export */   MinimalRouterStateSerializer: () => (/* binding */ MinimalRouterStateSerializer),
/* harmony export */   NavigationActionTiming: () => (/* binding */ NavigationActionTiming),
/* harmony export */   ROUTER_CANCEL: () => (/* binding */ ROUTER_CANCEL),
/* harmony export */   ROUTER_CONFIG: () => (/* binding */ ROUTER_CONFIG),
/* harmony export */   ROUTER_ERROR: () => (/* binding */ ROUTER_ERROR),
/* harmony export */   ROUTER_NAVIGATED: () => (/* binding */ ROUTER_NAVIGATED),
/* harmony export */   ROUTER_NAVIGATION: () => (/* binding */ ROUTER_NAVIGATION),
/* harmony export */   ROUTER_REQUEST: () => (/* binding */ ROUTER_REQUEST),
/* harmony export */   RouterStateSerializer: () => (/* binding */ RouterStateSerializer),
/* harmony export */   StoreRouterConnectingModule: () => (/* binding */ StoreRouterConnectingModule),
/* harmony export */   createRouterSelector: () => (/* binding */ createRouterSelector),
/* harmony export */   getRouterSelectors: () => (/* binding */ getRouterSelectors),
/* harmony export */   provideRouterStore: () => (/* binding */ provideRouterStore),
/* harmony export */   routerCancelAction: () => (/* binding */ routerCancelAction),
/* harmony export */   routerErrorAction: () => (/* binding */ routerErrorAction),
/* harmony export */   routerNavigatedAction: () => (/* binding */ routerNavigatedAction),
/* harmony export */   routerNavigationAction: () => (/* binding */ routerNavigationAction),
/* harmony export */   routerReducer: () => (/* binding */ routerReducer),
/* harmony export */   routerRequestAction: () => (/* binding */ routerRequestAction)
/* harmony export */ });
/* harmony import */ var _ngrx_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ngrx/store */ 18406);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ 63457);
/* harmony import */ var _angular_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/router */ 55501);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ 58989);








/**
 * An action dispatched when a router navigation request is fired.
 */
const ROUTER_REQUEST = '@ngrx/router-store/request';
const routerRequestAction = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createAction)(ROUTER_REQUEST, (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.props)());
/**
 * An action dispatched when the router navigates.
 */
const ROUTER_NAVIGATION = '@ngrx/router-store/navigation';
const routerNavigationAction = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createAction)(ROUTER_NAVIGATION, (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.props)());
/**
 * An action dispatched when the router cancels navigation.
 */
const ROUTER_CANCEL = '@ngrx/router-store/cancel';
const routerCancelAction = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createAction)(ROUTER_CANCEL, (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.props)());
/**
 * An action dispatched when the router errors.
 */
const ROUTER_ERROR = '@ngrx/router-store/error';
const routerErrorAction = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createAction)(ROUTER_ERROR, (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.props)());
/**
 * An action dispatched after navigation has ended and new route is active.
 */
const ROUTER_NAVIGATED = '@ngrx/router-store/navigated';
const routerNavigatedAction = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createAction)(ROUTER_NAVIGATED, (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.props)());
function routerReducer(state, action) {
  // Allow compilation with strictFunctionTypes - ref: #1344
  const routerAction = action;
  switch (routerAction.type) {
    case ROUTER_NAVIGATION:
    case ROUTER_ERROR:
    case ROUTER_CANCEL:
      return {
        state: routerAction.payload.routerState,
        navigationId: routerAction.payload.event.id
      };
    default:
      return state;
  }
}
class MinimalRouterStateSerializer {
  serialize(routerState) {
    return {
      root: this.serializeRoute(routerState.root),
      url: routerState.url
    };
  }
  serializeRoute(route) {
    const children = route.children.map(c => this.serializeRoute(c));
    return {
      params: route.params,
      data: route.data,
      url: route.url,
      outlet: route.outlet,
      title: route.title,
      routeConfig: route.routeConfig ? {
        path: route.routeConfig.path,
        pathMatch: route.routeConfig.pathMatch,
        redirectTo: route.routeConfig.redirectTo,
        outlet: route.routeConfig.outlet,
        title: typeof route.routeConfig.title === 'string' ? route.routeConfig.title : undefined
      } : null,
      queryParams: route.queryParams,
      fragment: route.fragment,
      firstChild: children[0],
      children
    };
  }
}
var NavigationActionTiming;
(function (NavigationActionTiming) {
  NavigationActionTiming[NavigationActionTiming["PreActivation"] = 1] = "PreActivation";
  NavigationActionTiming[NavigationActionTiming["PostActivation"] = 2] = "PostActivation";
})(NavigationActionTiming || (NavigationActionTiming = {}));
const DEFAULT_ROUTER_FEATURENAME = 'router';
const _ROUTER_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('@ngrx/router-store Internal Configuration');
const ROUTER_CONFIG = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.InjectionToken('@ngrx/router-store Configuration');
function _createRouterConfig(config) {
  return {
    stateKey: DEFAULT_ROUTER_FEATURENAME,
    serializer: MinimalRouterStateSerializer,
    navigationActionTiming: NavigationActionTiming.PreActivation,
    ...config
  };
}
class FullRouterStateSerializer {
  serialize(routerState) {
    return {
      root: this.serializeRoute(routerState.root),
      url: routerState.url
    };
  }
  serializeRoute(route) {
    const children = route.children.map(c => this.serializeRoute(c));
    return {
      params: route.params,
      paramMap: route.paramMap,
      data: route.data,
      url: route.url,
      outlet: route.outlet,
      title: route.title,
      routeConfig: route.routeConfig ? {
        component: route.routeConfig.component,
        path: route.routeConfig.path,
        pathMatch: route.routeConfig.pathMatch,
        redirectTo: route.routeConfig.redirectTo,
        outlet: route.routeConfig.outlet,
        title: route.routeConfig.title
      } : null,
      queryParams: route.queryParams,
      queryParamMap: route.queryParamMap,
      fragment: route.fragment,
      component: route.routeConfig ? route.routeConfig.component : undefined,
      root: undefined,
      parent: undefined,
      firstChild: children[0],
      pathFromRoot: undefined,
      children
    };
  }
}
class RouterStateSerializer {}
var RouterTrigger;
(function (RouterTrigger) {
  RouterTrigger[RouterTrigger["NONE"] = 1] = "NONE";
  RouterTrigger[RouterTrigger["ROUTER"] = 2] = "ROUTER";
  RouterTrigger[RouterTrigger["STORE"] = 3] = "STORE";
})(RouterTrigger || (RouterTrigger = {}));
/**
 * Shared router initialization logic used alongside both the StoreRouterConnectingModule and the provideRouterStore
 * function
 */
class StoreRouterConnectingService {
  constructor(store, router, serializer, errorHandler, config, activeRuntimeChecks) {
    this.store = store;
    this.router = router;
    this.serializer = serializer;
    this.errorHandler = errorHandler;
    this.config = config;
    this.activeRuntimeChecks = activeRuntimeChecks;
    this.lastEvent = null;
    this.routerState = null;
    this.trigger = RouterTrigger.NONE;
    this.stateKey = this.config.stateKey;
    if (!(0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.isNgrxMockEnvironment)() && (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.isDevMode)() && (activeRuntimeChecks?.strictActionSerializability || activeRuntimeChecks?.strictStateSerializability) && this.serializer instanceof FullRouterStateSerializer) {
      console.warn('@ngrx/router-store: The serializability runtime checks cannot be enabled ' + 'with the FullRouterStateSerializer. The FullRouterStateSerializer ' + 'has an unserializable router state and actions that are not serializable. ' + 'To use the serializability runtime checks either use ' + 'the MinimalRouterStateSerializer or implement a custom router state serializer.');
    }
    this.setUpStoreStateListener();
    this.setUpRouterEventsListener();
  }
  setUpStoreStateListener() {
    this.store.pipe((0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.select)(this.stateKey), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.withLatestFrom)(this.store)).subscribe(([routerStoreState, storeState]) => {
      this.navigateIfNeeded(routerStoreState, storeState);
    });
  }
  navigateIfNeeded(routerStoreState, storeState) {
    if (!routerStoreState || !routerStoreState.state) {
      return;
    }
    if (this.trigger === RouterTrigger.ROUTER) {
      return;
    }
    if (this.lastEvent instanceof _angular_router__WEBPACK_IMPORTED_MODULE_2__.NavigationStart) {
      return;
    }
    const url = routerStoreState.state.url;
    if (!isSameUrl(this.router.url, url)) {
      this.storeState = storeState;
      this.trigger = RouterTrigger.STORE;
      this.router.navigateByUrl(url).catch(error => {
        this.errorHandler.handleError(error);
      });
    }
  }
  setUpRouterEventsListener() {
    const dispatchNavLate = this.config.navigationActionTiming === NavigationActionTiming.PostActivation;
    let routesRecognized;
    this.router.events.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.withLatestFrom)(this.store)).subscribe(([event, storeState]) => {
      this.lastEvent = event;
      if (event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_2__.NavigationStart) {
        this.routerState = this.serializer.serialize(this.router.routerState.snapshot);
        if (this.trigger !== RouterTrigger.STORE) {
          this.storeState = storeState;
          this.dispatchRouterRequest(event);
        }
      } else if (event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_2__.RoutesRecognized) {
        routesRecognized = event;
        if (!dispatchNavLate && this.trigger !== RouterTrigger.STORE) {
          this.dispatchRouterNavigation(event);
        }
      } else if (event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_2__.NavigationCancel) {
        this.dispatchRouterCancel(event);
        this.reset();
      } else if (event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_2__.NavigationError) {
        this.dispatchRouterError(event);
        this.reset();
      } else if (event instanceof _angular_router__WEBPACK_IMPORTED_MODULE_2__.NavigationEnd) {
        if (this.trigger !== RouterTrigger.STORE) {
          if (dispatchNavLate) {
            this.dispatchRouterNavigation(routesRecognized);
          }
          this.dispatchRouterNavigated(event);
        }
        this.reset();
      }
    });
  }
  dispatchRouterRequest(event) {
    this.dispatchRouterAction(ROUTER_REQUEST, {
      event
    });
  }
  dispatchRouterNavigation(lastRoutesRecognized) {
    const nextRouterState = this.serializer.serialize(lastRoutesRecognized.state);
    this.dispatchRouterAction(ROUTER_NAVIGATION, {
      routerState: nextRouterState,
      event: new _angular_router__WEBPACK_IMPORTED_MODULE_2__.RoutesRecognized(lastRoutesRecognized.id, lastRoutesRecognized.url, lastRoutesRecognized.urlAfterRedirects, nextRouterState)
    });
  }
  dispatchRouterCancel(event) {
    this.dispatchRouterAction(ROUTER_CANCEL, {
      storeState: this.storeState,
      event
    });
  }
  dispatchRouterError(event) {
    this.dispatchRouterAction(ROUTER_ERROR, {
      storeState: this.storeState,
      event: new _angular_router__WEBPACK_IMPORTED_MODULE_2__.NavigationError(event.id, event.url, `${event}`)
    });
  }
  dispatchRouterNavigated(event) {
    const routerState = this.serializer.serialize(this.router.routerState.snapshot);
    this.dispatchRouterAction(ROUTER_NAVIGATED, {
      event,
      routerState
    });
  }
  dispatchRouterAction(type, payload) {
    this.trigger = RouterTrigger.ROUTER;
    try {
      this.store.dispatch({
        type,
        payload: {
          routerState: this.routerState,
          ...payload,
          event: this.config.routerState === 0 /* RouterState.Full */ ? payload.event : {
            id: payload.event.id,
            url: payload.event.url,
            // safe, as it will just be `undefined` for non-NavigationEnd router events
            urlAfterRedirects: payload.event.urlAfterRedirects
          }
        }
      });
    } finally {
      this.trigger = RouterTrigger.NONE;
    }
  }
  reset() {
    this.trigger = RouterTrigger.NONE;
    this.storeState = null;
    this.routerState = null;
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function StoreRouterConnectingService_Factory(t) {
    return new (t || StoreRouterConnectingService)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.Store), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_router__WEBPACK_IMPORTED_MODULE_2__.Router), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](RouterStateSerializer), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](ROUTER_CONFIG), _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.ACTIVE_RUNTIME_CHECKS));
  };
  /** @nocollapse */
  static #_2 = this.ɵprov = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"]({
    token: StoreRouterConnectingService,
    factory: StoreRouterConnectingService.ɵfac
  });
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](StoreRouterConnectingService, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable
  }], function () {
    return [{
      type: _ngrx_store__WEBPACK_IMPORTED_MODULE_0__.Store
    }, {
      type: _angular_router__WEBPACK_IMPORTED_MODULE_2__.Router
    }, {
      type: RouterStateSerializer
    }, {
      type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ErrorHandler
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [ROUTER_CONFIG]
      }]
    }, {
      type: undefined,
      decorators: [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
        args: [_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.ACTIVE_RUNTIME_CHECKS]
      }]
    }];
  }, null);
})();
/**
 * Check if the URLs are matching. Accounts for the possibility of trailing "/" in url.
 */
function isSameUrl(first, second) {
  return stripTrailingSlash(first) === stripTrailingSlash(second);
}
function stripTrailingSlash(text) {
  if (text?.length > 0 && text[text.length - 1] === '/') {
    return text.substring(0, text.length - 1);
  }
  return text;
}

/**
 * Connects the Angular Router to the Store.
 *
 * @usageNotes
 *
 * ```ts
 * bootstrapApplication(AppComponent, {
 *   providers: [
 *     provideStore({ router: routerReducer }),
 *     provideRouterStore(),
 *   ],
 * });
 * ```
 */
function provideRouterStore(config = {}) {
  return (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.makeEnvironmentProviders)([{
    provide: _ROUTER_CONFIG,
    useValue: config
  }, {
    provide: ROUTER_CONFIG,
    useFactory: _createRouterConfig,
    deps: [_ROUTER_CONFIG]
  }, {
    provide: RouterStateSerializer,
    useClass: config.serializer ? config.serializer : config.routerState === 0 /* RouterState.Full */ ? FullRouterStateSerializer : MinimalRouterStateSerializer
  }, {
    provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.ENVIRONMENT_INITIALIZER,
    multi: true,
    useFactory() {
      return () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.inject)(StoreRouterConnectingService);
    }
  }, StoreRouterConnectingService]);
}

/**
 * Connects RouterModule with StoreModule.
 *
 * During the navigation, before any guards or resolvers run, the router will dispatch
 * a ROUTER_NAVIGATION action, which has the following signature:
 *
 * ```
 * export type RouterNavigationPayload = {
 *   routerState: SerializedRouterStateSnapshot,
 *   event: RoutesRecognized
 * }
 * ```
 *
 * Either a reducer or an effect can be invoked in response to this action.
 * If the invoked reducer throws, the navigation will be canceled.
 *
 * If navigation gets canceled because of a guard, a ROUTER_CANCEL action will be
 * dispatched. If navigation results in an error, a ROUTER_ERROR action will be dispatched.
 *
 * Both ROUTER_CANCEL and ROUTER_ERROR contain the store state before the navigation
 * which can be used to restore the consistency of the store.
 *
 * Usage:
 *
 * ```typescript
 * @NgModule({
 *   declarations: [AppCmp, SimpleCmp],
 *   imports: [
 *     BrowserModule,
 *     StoreModule.forRoot(mapOfReducers),
 *     RouterModule.forRoot([
 *       { path: '', component: SimpleCmp },
 *       { path: 'next', component: SimpleCmp }
 *     ]),
 *     StoreRouterConnectingModule.forRoot()
 *   ],
 *   bootstrap: [AppCmp]
 * })
 * export class AppModule {
 * }
 * ```
 */
class StoreRouterConnectingModule {
  static forRoot(config = {}) {
    return {
      ngModule: StoreRouterConnectingModule,
      providers: [provideRouterStore(config)]
    };
  }
  /** @nocollapse */
  static #_ = this.ɵfac = function StoreRouterConnectingModule_Factory(t) {
    return new (t || StoreRouterConnectingModule)();
  };
  /** @nocollapse */
  static #_2 = this.ɵmod = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
    type: StoreRouterConnectingModule
  });
  /** @nocollapse */
  static #_3 = this.ɵinj = /* @__PURE__ */_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({});
}
(function () {
  (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](StoreRouterConnectingModule, [{
    type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
    args: [{}]
  }], null, null);
})();
function createRouterSelector() {
  return (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createFeatureSelector)(DEFAULT_ROUTER_FEATURENAME);
}
function getRouterSelectors(selectState = createRouterSelector()) {
  const selectRouterState = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectState, router => router && router.state);
  const selectRootRoute = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRouterState, routerState => routerState && routerState.root);
  const selectCurrentRoute = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRootRoute, rootRoute => {
    if (!rootRoute) {
      return undefined;
    }
    let route = rootRoute;
    while (route.firstChild) {
      route = route.firstChild;
    }
    return route;
  });
  const selectFragment = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRootRoute, route => route && route.fragment);
  const selectQueryParams = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRootRoute, route => route && route.queryParams);
  const selectQueryParam = param => (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectQueryParams, params => params && params[param]);
  const selectRouteParams = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectCurrentRoute, route => route && route.params);
  const selectRouteParam = param => (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRouteParams, params => params && params[param]);
  const selectRouteData = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectCurrentRoute, route => route && route.data);
  const selectRouteDataParam = param => (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRouteData, data => data && data[param]);
  const selectUrl = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectRouterState, routerState => routerState && routerState.url);
  const selectTitle = (0,_ngrx_store__WEBPACK_IMPORTED_MODULE_0__.createSelector)(selectCurrentRoute, route => {
    if (!route?.routeConfig) {
      return undefined;
    }
    return typeof route.routeConfig.title === 'string' ? route.routeConfig.title // static title
    : route.title; // resolved title
  });

  return {
    selectCurrentRoute,
    selectFragment,
    selectQueryParams,
    selectQueryParam,
    selectRouteParams,
    selectRouteParam,
    selectRouteData,
    selectRouteDataParam,
    selectUrl,
    selectTitle
  };
}

/**
 * DO NOT EDIT
 *
 * This file is automatically generated at build
 */

/**
 * Generated bundle index. Do not edit.
 */



/***/ })

}])
//# sourceMappingURL=node_modules_ngrx_router-store_fesm2022_ngrx-router-store_mjs-_777d0.js.map